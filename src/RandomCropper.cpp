//
//  NegativeCollector.cpp
//  HumanPoseDetector
//
//  Created by Lichao Chen on 12/3/12.
//  Copyright (c) 2012 Lichao Chen. All rights reserved.
//

#include "RandomCropper.h"
#include <boost/algorithm/string.hpp>
#include <boost/filesystem.hpp>
#include <fstream>
using namespace cv;
namespace fs = boost::filesystem;
namespace al = boost::algorithm;


// all patch and feature are created in this method.
// stored in feavec and all_mats
void RandomCropper::collectSrcDir(string fname) {

  vector<string> files;
  vector<fs::directory_entry> entries;

  copy_if(fs::directory_iterator(fname), fs::directory_iterator(),
          back_inserter(entries), [](const fs::directory_entry &e) -> bool {
            string ext = al::to_lower_copy(e.path().extension().string());
            return (ext == ".png" || ext == ".jpg");
          });
  transform(entries.begin(), entries.end(), back_inserter(files),
            [](const fs::directory_entry &e) {
              return e.path().filename().string();
            });
  sort(files.begin(), files.end());
  auto itend = files.rend(); // return a reverse of file name ?

#ifdef DEBUG
  itend = files.rbegin() + 50;
#endif

  //  create all patches
  for_each(files.rbegin(), itend, [this, fname](string s) {
    Mat img = imread(fname + s);
    cout << fname + s << endl;
    this->setUp(img);
  });
  // create all features storing into feavec
  auto it = all_mats.begin();
  Feature f(*it);
  // the matrix feavec has dim (row*col of hog, number of image)
  int numcol = static_cast<int>(f.vec.size());
  int numrow = static_cast<int>(all_mats.size());

  feavec = Mat(numrow, numcol, CV_32F);
  for (int i = 0; i < numrow; i++) {
    //feavec.row(i) = Mat(Feature(*it).vec).t();
    cout << "*******"<< endl;
    feavec.row(i) = Mat(Feature(*it).vec);
    it++;
  }

  cout << "Feature Matrix Created" << endl;
  cout << "Rows:\t" << numrow << endl;
  cout << "Cols:\t" << numcol << endl;
  }

//never used
void RandomCropper::kmean() { kmean(100); }

//never used
void RandomCropper::kmean(int k) {
  auto category = vector<int>(all_mats.size());
  kmeans(feavec, k, category, TermCriteria(CV_TERMCRIT_ITER, 30, 0), 5,
         KMEANS_PP_CENTERS);
  for_each(category.begin(), category.end(), [](int i) { cout << i << endl; });
}

//never used
void RandomCropper::pca() {
  PCA a(feavec, noArray(), CV_PCA_DATA_AS_ROW, 0.95);
  auto shortfea = a.project(feavec);

  cout << "PCA done" << endl;
  cout << "Rows:\t" << shortfea.rows << endl;
  cout << "Cols:\t" << shortfea.cols << endl;
  feavec = shortfea;
}

void RandomCropper::exportFeatures(string fname) {
  //	FileStorage fs(fname, FileStorage::WRITE);
  //	fs<<"feature"<<feavec;
  //	fs.release();
  ofstream fout(fname);
  fout << feavec.rows << endl;
  fout << feavec.cols << endl;

  for (int i = 0; i < feavec.rows; i++) {
    Mat tempr = feavec.row(i);
    for (auto j = tempr.begin<float>(); j != tempr.end<float>(); j++) {
      fout << *j << "\t";
    }
    fout << "\n"; // I think endl is slow, haven't tested :)
  }
  fout.close();
}
void RandomCropper::exportSeperators(string fname) {
  ofstream fout(fname);
  for_each(seperators.begin(), seperators.end(),
           [&fout](int i) { fout << i << endl; });
  fout.close();
}

// write store all matrice from all_mat vector into disk.
void RandomCropper::exportPatches(string fname) {

  if (*fname.rbegin() != '/') {
    cout << (int)*fname.rbegin() << endl;
    fname = fname + "/";
  }
  for (size_t i = 0; i < all_mats.size(); i++) {
    imwrite(fname + to_string(i + 1) + ".jpg", all_mats[i]);
  }
}

// input: one image matrix
// append all matrice generated by prymaid into all mat.
// each level of generation obey uniform distribution.
void RandomCropper::setUp(Mat img) {
  seperators.push_back(all_mats.size());
  // all mat store all the image segments get from each image.
  // these images can be overlapped.
  //the first element of seperator should be zero sice after
  //initialization, the all mats defined in RandomCropper.h
  //(vector of matrix) is size zero.
  // seperator is to define how many image patches in each image
  vector<double> level_scale;
  // cout<<"windows ratio:"<<patch_r<<"\t"<<patch_c<<endl;

  double scale = 1.;
  double scale0 = 1.2;
  int levels = 0;
  int maxl = 40;
  if (!toprymaid) {
    maxl = 1;
  }

  //create  prymaid matrix stores level scale
  for (levels = 0; levels < maxl; levels++) {
    level_scale.push_back(scale);
    if (cvRound(img.cols / scale) < patch_c ||
        cvRound(img.rows / scale) < patch_r || scale0 <= 1)
      break;
    scale *= scale0;
  }

  levels = max(levels, 1);
  level_scale.resize(levels);
  size_t i;
  for (i = 0; i < level_scale.size(); i++) {
    scale = level_scale[i];
    int imgs = patchesPerImage / scale / scale;
    Size sz(cvRound(img.cols / scale), cvRound(img.rows / scale));
    Mat smaller_img;

    if (sz == img.size())
      smaller_img = img;
    else {
      resize(img, smaller_img, sz); //TODO Where does this function come from? Guess smaller_image = resize(image)
    }
    // cout<<"windows scale:"<<smaller_img.rows<<"\t"<<smaller_img.cols<<endl;
    if (smaller_img.rows - patch_r > -1 && smaller_img.cols - patch_c > -1 &&
        imgs > 0) {
      vector<int> rowvs(imgs), colvs(imgs);
      cout << imgs << endl;
      cv::randu(rowvs, 0, smaller_img.rows - patch_r + 1);
      cv::randu(colvs, 0, smaller_img.cols - patch_c + 1);
      Size scaled_win_size(cvRound(patch_c * scale), cvRound(patch_r * scale));
      for (auto rs = rowvs.begin(), cs = colvs.begin(); rs != rowvs.end();
           rs++, cs++) {
        // rect list
        all_rects.push_back(Rect(Point2d(*cs, *rs) * scale, scaled_win_size));
        cout << *cs << "\t" << *rs << endl;
        // sub mat list
        Mat temp =
            smaller_img(Range(*rs, *rs + patch_r), Range(*cs, *cs + patch_c))
                .clone();
        all_mats.push_back(temp);
      }
    }
  }
}
